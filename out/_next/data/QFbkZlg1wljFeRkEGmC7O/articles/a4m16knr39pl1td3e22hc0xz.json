{"pageProps":{"article":{"id":256,"documentId":"a4m16knr39pl1td3e22hc0xz","title":"ReactでsetIntervalを扱う方法","content":"ReactのWebアプリで一定間隔でカウントアップする処理を実装した際に直面した課題と、その解決策について解説します。\n\nこの方法を理解すれば、Reactで `setInterval` を適切に扱う技術が身に付きます。\n\nその課題と解決策について、実例を交えながら解説します。\n\n---\n\n# 課題：`setInterval`の扱いによる問題\n\nあるアプリで、特定条件を満たす場合にカウントアップし、条件を満たさない場合はカウントをリセットする機能を実装しました。\n\n以下がそのコード例です。\n\n## 問題のコード\n\n```tsx\nimport React, { useState, useEffect, useRef } from 'react';\n\nconst App = () => {\n    const [timer, setTimer] = useState(0);\n    const intervalRef = useRef(null);\n    const [condition, setCondition] = useState([]);\n    \n    // 別のuseEffectでupdateConditionが実行される\n    const updateCondition = (data) => {\n        setCondition((prev) => [...data, {hoge: data.hoge, fuga: data.fuga}])\n    }\n    \n    const countUpTimer = () => {\n        return setInterval(() => {\n            setTimer((prevTimer) => prevTimer + 1);\n        }, 1000)\n    }\n\n    // 特定の条件でカウントアップ開始\n    useEffect(() => {\n        if (condition.length > 1) {\n            if (!intervalRef.current) {\n                intervalRef.current = countUpTimer()\n            }\n        } else {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n            setTimer(0);\n        }\n\n        return () => clearInterval(intervalRef.current);\n    }, [condition]);\n\n    // その他の処理は省略\n\n    return (\n        <div>\n            <h1>Timer: {timer}</h1>\n        </div>\n    );\n}\n```\n\n## 問題点\n\n`useEffect`で `condition` の状態が変わるたびに、`setInterval`のコールバックが停止する問題が発生しました。この現象は、`setInterval`がクロージャの内部で古い`state`を参照してしまうために起こります。\n\n---\n\n# 解決策：`useInterval`カスタムフックの実装\n\nこの問題を解決するには、`setInterval`を再利用可能な形でカプセル化し、最新の`state`を正しく参照できるようにするカスタムフックを作成します。\n\n## `useInterval.js`の実装\n\n以下のように、`useInterval`カスタムフックを実装します。\n\n```tsx\nimport { useEffect, useRef } from 'react';\n\nexport function useInterval(callback, delay) {\n    const savedCallback = useRef();\n\n    // 最新のコールバックを保存\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    useEffect(() => {\n        function func() {\n            savedCallback.current();\n        }\n        if (delay !== null) {\n            let id = setInterval(func, delay);\n            return () => clearInterval(id);\n        }\n    }, [delay]);\n}\n\n```\n\n- `callback`: 実行したい処理\n- `delay`: 実行間隔（ミリ秒）。`null`の場合は実行を停止します。\n\n`useInterval`を使用すると、タイマーのロジックが簡潔になり、依存関係の管理がし易くなります。\n\n---\n\n## `useInterval`の利用例\n\nカスタムフックを活用すると、アプリのロジックがシンプルになります。\n\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { useInterval } from './useInterval';\n\nconst App = () => {\n    const [timer, setTimer] = useState(0);\n\n    const condition = () => {\n        // 別のstateを使って条件の計算（例: 特定の状態かどうか）\n    };\n\n    useInterval(() => {\n        setTimer((prevTimer) => prevTimer + 1);\n    }, condition ? 1000 : null);\n\n    useEffect(() => {\n        if (!condition) {\n            setTimer(0);\n        }\n    }, [condition]);\n\n    // その他の処理は省略\n\n    return (\n        <div>\n            <h1>Timer: {timer}</h1>\n        </div>\n    );\n};\n\n```\n\n### 主なポイント\n\n- `useInterval`を利用することで、`setInterval`の管理が明示的かつ安全になります。\n- `condition`が`false`の場合は`delay`が`null`になるため、カウントアップが停止し、カウンタをリセットします。\n\n---\n\n# まとめ\n\n`setInterval`をReactで適切に扱うには、クロージャや依存関係の管理に注意が必要です。\n\n今回紹介した`useInterval`カスタムフックを使用することで、コードの可読性と再利用性を高めることができます。\n\nReact開発の中で`setInterval`を安全かつ効率的に使用する方法を学び、より洗練されたコードを書けるようにしていきましょう！\n\n---\n\n# 参考資料\n\nhttps://overreacted.io/making-setinterval-declarative-with-react-hooks/\n\nhttps://www.geeksforgeeks.org/reactjs-useinterval-custom-hook/\n\nhttps://usehooks-ts.com/react-hook/use-interval\n\n---\n\n","createdAt":"2025-05-19T08:50:57.429Z","updatedAt":"2025-06-05T23:53:22.743Z","publishedAt":"2025-06-05T23:53:22.753Z","docId":"bi47mel6x5t6qfakip03z15z","tags":[{"id":16,"documentId":"zg5iwdiznwk0mb2s77f9xta3","createdAt":"2025-05-19T09:48:07.933Z","updatedAt":"2025-05-19T09:48:07.933Z","publishedAt":"2025-05-19T09:48:07.940Z","name":"Frontend"},{"id":26,"documentId":"koshlmrejvmni8nxdnq7cir3","createdAt":"2025-05-19T09:50:01.361Z","updatedAt":"2025-05-19T09:50:01.361Z","publishedAt":"2025-05-19T09:50:01.379Z","name":"React"}],"thumbnail":[{"id":12,"documentId":"nex0mp610l9bngw1nihrdpvu","name":"20250513-08.png","alternativeText":null,"caption":null,"width":1503,"height":844,"formats":{"thumbnail":{"name":"thumbnail_20250513-08.png","hash":"thumbnail_20250513_08_a7cf147e40","ext":".png","mime":"image/png","path":null,"width":245,"height":138,"size":10.42,"sizeInBytes":10422,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/thumbnail_20250513_08_a7cf147e40.png"},"medium":{"name":"medium_20250513-08.png","hash":"medium_20250513_08_a7cf147e40","ext":".png","mime":"image/png","path":null,"width":750,"height":421,"size":41.33,"sizeInBytes":41334,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/medium_20250513_08_a7cf147e40.png"},"large":{"name":"large_20250513-08.png","hash":"large_20250513_08_a7cf147e40","ext":".png","mime":"image/png","path":null,"width":1000,"height":562,"size":57.76,"sizeInBytes":57756,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/large_20250513_08_a7cf147e40.png"},"small":{"name":"small_20250513-08.png","hash":"small_20250513_08_a7cf147e40","ext":".png","mime":"image/png","path":null,"width":500,"height":281,"size":24.93,"sizeInBytes":24929,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/small_20250513_08_a7cf147e40.png"}},"hash":"20250513_08_a7cf147e40","ext":".png","mime":"image/png","size":17.35,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/20250513_08_a7cf147e40.png","previewUrl":null,"provider":"@strapi/provider-upload-aws-s3","provider_metadata":null,"createdAt":"2025-05-20T07:43:33.476Z","updatedAt":"2025-05-20T07:43:33.476Z","publishedAt":"2025-05-20T07:43:33.476Z"}]}},"__N_SSG":true}