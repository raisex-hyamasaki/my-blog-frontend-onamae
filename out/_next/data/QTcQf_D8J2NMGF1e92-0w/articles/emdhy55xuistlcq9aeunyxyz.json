{"pageProps":{"article":{"id":199,"documentId":"emdhy55xuistlcq9aeunyxyz","title":"DynamoDBの並列Scan","content":"前回の記事「 [DynamoDBからの全データ取得におけるプラクティス](https://my-blog-frontend-two.vercel.app/articles/o0cmjsrwp73fm9jd2i3s0d80)  」では、**パーティション分散と並列Query**を活用した全データ取得の効果を検証しました。\n\n今回の記事では、もう一つの手法である**並列Scan**について取り上げ、どのような効果が得られるのかを実験します。\n\n---\n\n# 並列Scanとは？\n\n**並列Scan**は、DynamoDBのパーティション分散を利用し、データのスキャン処理を複数のセグメント（Segment）に分割して並列で実行する方法です。\n\n通常のScan操作は1つのプロセスで順次処理を行うため、データ量が増えるほど時間がかかります。\n\n一方、並列Scanでは複数のワーカーを用いて並列処理を行うため、大量データのスキャンを効率化できます。\n\n## 基本動作\n\n- **Segment**: データを分割する単位。\n- **TotalSegments**: 全体の分割数。\n- 各ワーカーが指定されたSegmentを担当し、全体のデータセットを並列に処理します。\n\n---\n\n# 実験内容\n\n以下の条件で並列Scanを実施し、処理時間を測定しました。\n\n- データ量: 3万件、10万件\n- メモリ量: 512MB、2048MB\n- セグメント数: 2, 3, 4, 5, 10\n\n### ソースコード\n\n以下は実験に使用したAWS Lambda用のPythonコードです。\n\n```python\nimport boto3\nimport os\nfrom concurrent.futures import ThreadPoolExecutor\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table('test_datas')\n\n# 最大ワーカー数\nmax_workers = min(32, os.cpu_count() * 5)\n\ndef parallel_scan(segment, total_segments):\n    print(f'segment = {segment}, total_segments = {total_segments}')\n    items = []\n    options = {\n        'Segment': segment,\n        'TotalSegments': total_segments\n    }\n    done = False\n\n    while True:\n        response = table.scan(**options)\n        next_token = response.get('LastEvaluatedKey', None)\n        items.extend(response['Items'])\n        if next_token:\n            options['ExclusiveStartKey'] = next_token\n        else:\n            break\n    return items\n\ndef lambda_handler(event, context):\n    total_segments = 2  # 並列度を調整\n\n    # ThreadPoolExecutorを使用して並列スキャンを実行\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = [executor.submit(parallel_scan, segment, total_segments) for segment in range(total_segments)]\n        results = []\n        for future in futures:\n            results.extend(future.result())\n\n        print(f'{len(results)}件')\n    return {\n        'StatusCode': 200\n    }\n\n```\n\n---\n\n## 実験結果\n\n### データ量: 3万件\n\n| メモリ量 | セグメント数 | 処理時間 |\n| --- | --- | --- |\n| 512MB | 2 | 15秒 |\n|  | 3 | 14.4秒 |\n|  | 4 | 14.6秒 |\n|  | 5 | 14.4秒 |\n|  | 10 | 14.3秒 |\n| 2048MB | 2 | 4秒 |\n|  | 3 | 4.3秒 |\n|  | 4 | 4.1秒 |\n|  | 5 | 4秒 |\n|  | 10 | 4.3秒 |\n\n---\n\n### データ量: 10万件\n\n| メモリ量 | セグメント数 | 処理時間 |\n| --- | --- | --- |\n| 512MB | 2 | 49秒 |\n|  | 3 | 49秒 |\n|  | 4 | 52.3秒 |\n|  | 5 | 53秒 |\n|  | 10 | 52秒 |\n| 2048MB | 2 | 13.1秒 |\n|  | 3 | 14秒 |\n|  | 4 | 13.6秒 |\n|  | 5 | 14.6秒 |\n|  | 10 | 14.2秒 |\n\n---\n\n## まとめ\n\n### パフォーマンス\n\n- **メモリ量の影響**:\nメモリを2048MBに増加させると処理時間が大幅に短縮。\n- **セグメント数の影響**:\nセグメント数の増加による処理時間の改善は限定的。\n\n### コストと効率\n\n- **普通のScanと比較**:\nメモリ量を増やした並列Scanの方が高速。ただし、メモリ量を増やす分、コストが増加する点には注意が必要です。\n- **並列Queryと比較**:\nパーティションキーを活用した並列Queryの方がさらに高速で効率的。並列Scanは特定のユースケース（例: パーティションキーが不明、全件取得が必要）で有効です。\n\n---\n\n## 結論\n\n**並列Scanは特定の状況で有効な手法ですが、パフォーマンス最適化を考えるなら、並列Queryの方がより効果的です。**\n\n次のような場合に並列Scanを検討してください:\n\n- 全データをスキャンする必要がある。\n- パーティションキーの設計が不十分でQueryが使えない。\n\n効率的なDynamoDB運用の為には、データモデル設計を見直し、並列Queryを優先することをおすすめします！\n\n---\n\n","createdAt":"2025-05-19T08:50:57.685Z","updatedAt":"2025-06-01T23:52:36.485Z","publishedAt":"2025-06-01T23:52:36.499Z","docId":"gl8fxc0imylqstbwjwcwpnsf","tags":[{"id":10,"documentId":"cxt2tbnsy05cazm17p3pp1a3","createdAt":"2025-05-19T09:46:58.860Z","updatedAt":"2025-05-19T09:46:58.860Z","publishedAt":"2025-05-19T09:46:58.868Z","name":"AWS"},{"id":12,"documentId":"c3lesvkdvjiq7y5zfx9mx0tu","createdAt":"2025-05-19T09:47:14.973Z","updatedAt":"2025-05-19T09:47:14.973Z","publishedAt":"2025-05-19T09:47:14.980Z","name":"Backend"},{"id":14,"documentId":"ufw8l9386d4flb8sddy84mft","createdAt":"2025-05-19T09:47:52.868Z","updatedAt":"2025-05-19T09:47:52.868Z","publishedAt":"2025-05-19T09:47:52.876Z","name":"DynamoDB"}],"thumbnail":[{"id":15,"documentId":"hszel53rqwh0ryeez8krf8t8","name":"20250513-11.png","alternativeText":null,"caption":null,"width":1503,"height":844,"formats":{"thumbnail":{"name":"thumbnail_20250513-11.png","hash":"thumbnail_20250513_11_bfd0628b18","ext":".png","mime":"image/png","path":null,"width":245,"height":138,"size":9.08,"sizeInBytes":9076,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/thumbnail_20250513_11_bfd0628b18.png"},"medium":{"name":"medium_20250513-11.png","hash":"medium_20250513_11_bfd0628b18","ext":".png","mime":"image/png","path":null,"width":750,"height":421,"size":34.34,"sizeInBytes":34341,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/medium_20250513_11_bfd0628b18.png"},"large":{"name":"large_20250513-11.png","hash":"large_20250513_11_bfd0628b18","ext":".png","mime":"image/png","path":null,"width":1000,"height":562,"size":49.02,"sizeInBytes":49018,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/large_20250513_11_bfd0628b18.png"},"small":{"name":"small_20250513-11.png","hash":"small_20250513_11_bfd0628b18","ext":".png","mime":"image/png","path":null,"width":500,"height":281,"size":20.57,"sizeInBytes":20567,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/small_20250513_11_bfd0628b18.png"}},"hash":"20250513_11_bfd0628b18","ext":".png","mime":"image/png","size":15.11,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/20250513_11_bfd0628b18.png","previewUrl":null,"provider":"@strapi/provider-upload-aws-s3","provider_metadata":null,"createdAt":"2025-05-20T07:45:16.265Z","updatedAt":"2025-05-20T07:45:16.265Z","publishedAt":"2025-05-20T07:45:16.265Z"}]}},"__N_SSG":true}