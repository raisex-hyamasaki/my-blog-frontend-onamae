{"pageProps":{"article":{"id":198,"documentId":"o0cmjsrwp73fm9jd2i3s0d80","title":"DynamoDBからの全データ取得におけるプラクティス","content":"弊社は、サーバーレスアーキテクチャの開発を得意としており、Amazon DynamoDBやAWS Lambda等のサービスを活用した効率的でスケーラブルなシステム設計を提供しています。\n\nその中で、アプリケーション開発において「画面に全データを一覧表示する」という仕様はよく見られるものの、NoSQLデータベースでは適切なアプローチを選ばないとパフォーマンスやコストの課題が発生します。\n\n本記事では、DynamoDBから全データを取得する方法と、その実験結果をもとにした設計上の注意点について解説します。\n\n---\n\n# **全データ取得の課題**\n\nDynamoDBはスケーラビリティに優れたデータベースですが、設計次第で処理性能が大きく変化します。\n\n特に以下の点に注意が必要です:\n\n- **Scanのリスク**:\nScanはテーブル全体をフルスキャンするため、膨大なデータ量の場合に時間がかかり、コストも増加します。\n- **Queryの可能性**:\n適切に設計されたパーティションキーとソートキーを利用することで、特定のデータセットを効率的に取得できます。\n\n---\n\n# **実験概要**\n\nDynamoDBで3万件、10万件のデータを用意し、ScanとQueryの処理時間を比較しました。以下の2つのアプローチを検証しています。\n\n1. **全データを単一パーティションにまとめる**\n2. **データを複数パーティションに分散させる**\n\nデータはAWS公式サンプルリポジトリ [aws-samples/csv-to-dynamodb](https://github.com/aws-samples/csv-to-dynamodb) のtestfile.csvを使用。\n\n実験のパターンごとに少しデータを修正し、投入します。\n\n---\n\n## **実験1: 単一パーティションにまとめる**\n\n### **手法**\n\n- **パーティションキー**: 固定値（例: `DATA`）を設定するGSIを作成。\n- **目的**: 単一パーティションにデータを格納し、Queryで効率的に全データを取得する。\n\n**データ構造例:**\n\n| DataType (PK) | uuid | Country | ItemType |\n| --- | --- | --- | --- |\n| DATA | 535113847 | Azerbaijan | Snacks |\n| DATA | 874708545 | Panama | Cosmetics |\n\nQueryのソースコード(AWS Lambda用)\n\n```python\nimport boto3\nfrom boto3.dynamodb.conditions import Key\n\ndef lambda_handler(event, context):\n    table_name = 'test_datas'\n    region = 'us-east-1'\n    gsi_name = 'DataType-index'\n\n    # DynamoDBクライアントの初期化\n    dynamodb = boto3.resource('dynamodb', region_name=region)\n    table = dynamodb.Table(table_name)\n\n    # クエリ条件 DataType が DATA\n    key_condition_expression = Key('DataType').eq('DATA')\n\n    try:\n        options = {\n            'IndexName': gsi_name,\n            'KeyConditionExpression': key_condition_expression,\n            'ReturnConsumedCapacity': 'TOTAL'\n        }\n        while True:\n            response = table.query(**options)\n            next_token = response.get('LastEvaluatedKey', None)\n            print(next_token)\n\n            if next_token:\n                options['ExclusiveStartKey'] = next_token\n            else:\n                break\n\n        return {\n            'statusCode': 200\n        }\n    except Exception as e:\n        print('エラー:', e)\n        return {\n            'statusCode': 500,\n            'body': 'サーバーエラーが発生しました'\n        }\n\n```\n\nScanのソースコード(AWS Lambda用)\n\n```python\nimport boto3\n\ndef lambda_handler(event, context):\n    table_name = 'test_datas_'\n    region = 'us-east-1'\n\n    # DynamoDBクライアントの初期化\n    dynamodb = boto3.resource('dynamodb', region_name=region)\n    table = dynamodb.Table(table_name)\n\n    try:\n        options = {\n            'ReturnConsumedCapacity': 'TOTAL'\n        }\n        while True:\n            response = table.scan(**options)\n            next_token = response.get('LastEvaluatedKey', None)\n            print(next_token)\n\n            if next_token:\n                options['ExclusiveStartKey'] = next_token\n            else:\n                break\n\n        return {\n            'statusCode': 200\n        }\n    except Exception as e:\n        print('エラー:', e)\n        return {\n            'statusCode': 500,\n            'body': 'サーバーエラーが発生しました'\n        }\n\n```\n\n### **結果(Lambdaのウォームスタート)**\n\n| データ量 | メモリ (MB) | Query (秒) | Scan (秒) |\n| --- | --- | --- | --- |\n| 3万件 | 512 | 15 | 15 |\n|  | 2048 | 4 | 5 |\n| 10万件 | 512 | 50 | 50 |\n|  | 2048 | 13 | 15 |\n\n### **考察**\n\n- 全データ取得という観点ではScanもQueryもあまり処理時間の違いはないことがわかります。\n- データ量が増えると取得時間が数十秒かかるため、ユーザー体験の悪化が懸念されます。\n- メモリを増やすことで処理時間が短縮されますが、それでも数万件以上では非同期処理や別の工夫が必要です。\n\n---\n\n## **実験2: データを複数パーティションに分散する**\n\n### **手法**\n\n- **パーティションキー**: シャード番号やランダム識別子を付加。\n- **目的**: データを複数のパーティションに分散し、並列処理で取得速度を向上させる。\n\n**データ構造例:**\n\n| ItemCategory (PK) | uuid | DataType | Country | ItemType |\n| --- | --- | --- | --- | --- |\n| ItemCategory#11 | 535113847 | DATA | Azerbaijan | Snacks |\n| ItemCategory#5 | 874708545 | DATA | Panama | Cosmetics |\n\n並列でクエリを実行するソースコード(AWS Lambda用)\n\n```python\nimport boto3\nimport os\nfrom botocore.config import Config\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# DynamoDB テーブル名\nTABLE_NAME = \"test_datas\"\nSHARD_COUNT = 12  # シャードの数\n\ncustom_config = Config(\n    max_pool_connections=12\n)\n# DynamoDB クライアントの作成\ndynamodb = boto3.client('dynamodb', config=custom_config)\n\n# 最大ワーカー数\nmax_workers = min(32, os.cpu_count() * 5)\n\ndef query_shard(partition_key):\n    \"\"\"指定されたシャードをクエリする関数\"\"\"\n    try:\n        items = []\n        options = {\n            'TableName': TABLE_NAME,\n            'IndexName': 'ItemCategory-index',\n            'KeyConditionExpression': \"ItemCategory = :pk\",\n            'ExpressionAttributeValues': {\":pk\": {\"S\": partition_key}}\n        }\n        while True:\n            response = dynamodb.query(**options)\n            items.extend(response.get(\"Items\", []))\n            next_token = response.get('LastEvaluatedKey', None)\n            if next_token:\n                options['ExclusiveStartKey'] = next_token\n            else:\n                break\n        print(f\"{partition_key}: {len(items)}件\")\n        return items\n    except Exception as e:\n        print(f\"Error querying {partition_key}: {e}\")\n        return []\n\ndef query_all_shards():\n    \"\"\"すべてのシャードを並列でクエリする\"\"\"\n    print(f'max_workers: {max_workers}')\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        # シャードごとにクエリを実行\n        futures = {\n            executor.submit(query_shard, f\"ItemCategory#{shard_number}\"): shard_number\n            for shard_number in range(1, SHARD_COUNT + 1)\n        }\n        \n        # 結果を集約\n        results = []\n        for future in as_completed(futures):\n            try:\n                shard_result = future.result()\n                results.extend(shard_result)\n            except Exception as e:\n                print(f\"Error in shard {futures[future]}: {e}\")\n        \n        return results\n\ndef lambda_handler(event, context):\n    \"\"\"Lambda 関数のエントリポイント\"\"\"\n    results = query_all_shards()\n    print(f'{len(results)}件')\n    return {\n        \"statusCode\": 200,\n        \"body\": {\n        }\n    }\n```\n\n### **結果(Lambdaのウォームスタート)**\n\n| データ量 | メモリ (MB) | Query (秒) |\n| --- | --- | --- |\n| 3万件 | 512 | 11 |\n|  | 2048 | 3.3 |\n| 10万件 | 512 | Out of memory Error |\n|  | 2048 | 10 |\n\n### **考察**\n\n- パーティション分散により取得速度が向上しました。\n- データ量が増えるとOut of Memoryエラーが発生する可能性があるため、クエリ方法やメモリ管理の工夫が必要です。\n\n---\n\n# **まとめ**\n\nDynamoDBで全データを取得する際のベストプラクティスは以下の通りです。\n\n1. **データ量が少ない場合**: 単一パーティションでQueryを使用しても問題ありません。\n2. **データ量が多い場合**: パーティションを分散し、並列でQueryを実行することで効率的にデータを取得可能です。\n3. **非同期処理**: データ量が多い場合は同期処理ではなく、非同期でデータを取得する設計を検討しましょう。\n4. **仕様の再検討**: 全データを一覧表示する代わりに、条件を絞り込んで表示する仕様に変更できないかをまず検討するべきでしょう。\n\n効率的なデータ取得には、データ設計とアプリケーション設計のバランスが欠かせません。本記事を参考に、DynamoDBを活用したパフォーマンスの高いアプリケーションを構築してください。\n\n---\n\n","createdAt":"2025-05-19T08:50:57.627Z","updatedAt":"2025-06-01T23:46:48.939Z","publishedAt":"2025-06-01T23:46:48.952Z","docId":"hmwidddh8kfenx2ifd67lygc","tags":[{"id":10,"documentId":"cxt2tbnsy05cazm17p3pp1a3","createdAt":"2025-05-19T09:46:58.860Z","updatedAt":"2025-05-19T09:46:58.860Z","publishedAt":"2025-05-19T09:46:58.868Z","name":"AWS"},{"id":12,"documentId":"c3lesvkdvjiq7y5zfx9mx0tu","createdAt":"2025-05-19T09:47:14.973Z","updatedAt":"2025-05-19T09:47:14.973Z","publishedAt":"2025-05-19T09:47:14.980Z","name":"Backend"}],"thumbnail":[{"id":14,"documentId":"hu10hoivv38q6d2d58e0uyhu","name":"20250513-10.png","alternativeText":null,"caption":null,"width":1504,"height":844,"formats":{"thumbnail":{"name":"thumbnail_20250513-10.png","hash":"thumbnail_20250513_10_4b5734cef6","ext":".png","mime":"image/png","path":null,"width":245,"height":137,"size":13.91,"sizeInBytes":13908,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/thumbnail_20250513_10_4b5734cef6.png"},"medium":{"name":"medium_20250513-10.png","hash":"medium_20250513_10_4b5734cef6","ext":".png","mime":"image/png","path":null,"width":750,"height":421,"size":54.78,"sizeInBytes":54781,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/medium_20250513_10_4b5734cef6.png"},"small":{"name":"small_20250513-10.png","hash":"small_20250513_10_4b5734cef6","ext":".png","mime":"image/png","path":null,"width":500,"height":281,"size":33.51,"sizeInBytes":33508,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/small_20250513_10_4b5734cef6.png"},"large":{"name":"large_20250513-10.png","hash":"large_20250513_10_4b5734cef6","ext":".png","mime":"image/png","path":null,"width":1000,"height":561,"size":78.42,"sizeInBytes":78418,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/large_20250513_10_4b5734cef6.png"}},"hash":"20250513_10_4b5734cef6","ext":".png","mime":"image/png","size":22.83,"url":"https://stg-raisex-tech-blog.s3.ap-northeast-1.amazonaws.com/20250513_10_4b5734cef6.png","previewUrl":null,"provider":"@strapi/provider-upload-aws-s3","provider_metadata":null,"createdAt":"2025-05-20T07:44:41.591Z","updatedAt":"2025-05-20T07:44:41.591Z","publishedAt":"2025-05-20T07:44:41.594Z"}]}},"__N_SSG":true}